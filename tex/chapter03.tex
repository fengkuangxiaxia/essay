%%==================================================
%% chapter03.tex for SJTU Master Thesis
%% Encoding: UTF-8
%%==================================================

\chapter{Trivium算法在物联网中的应用}
\label{chap:use}

在第二章中，本文详细讨论了Trivium算法的结构和一些设计准则。现在本文要考查Trivium算法是否能在物联网中胜任加密算法一职。因此本章将首先讨论Trivium算法在物联网中的优势，然后给出一个假想的应用场景下Trivium算法的完整的应用。

\section{Trivium算法的优势}
\label{sec:advantage}

\subsection{高效性}

考虑到对物联网的一个期望是未来能够实现自动化，那么对于实时性就有很高的要求，这样才能保证各物品之间相互的协调能不出错，因此作为要在物联网中使用的加密算法，首当其冲的要求就是加密算法的高效性了。Trivium算法作为加密算法的高效性的一个保证就是其是流密码，流密码本身就具有实现简单、便于硬件实现、加密解密速度快、低错误传播等特点，因此作为流密码一种的Trivium算法自然也具备这些特点。

当然，流密码内部也有速度的优劣之分。一般而言，要提升流密码算法的效率有两种方法：第一种方法是尽可能减少逻辑门数，使整体结构更为紧凑；第二种方法是改变传统流密码每个cycle只产生一位密钥的做法，转为每个cycle产生多位密钥。显然，这两种做法各有优劣，第一种减少逻辑门数使结构紧凑的做法不适用于要求高速加密的环境，即产生同样位数的密钥需要更少的cycle；而第二种一次cycle产生多位密钥的做法则不适用于要求紧凑结构的环境，比如芯片大小的限制。

Trivium算法并没有固定使用上述的两种方法的某一种，而是一种可变结构，能够成为上述两种两种方法的任意一种。一般提到的Trivium算法属于第一种方法，共使用3488个逻辑门，每个cycle产生一位密钥，但是因为至少要64个cycle才有可能使每个内部状态位被使用，因此可以并行地一个cycle产生64位密钥，此时共使用5504个逻辑门。可见Trivium算法可以适应不同的加密速度或空间的要求。

另外根据eSTREAM的分析，在x86平台加密大块数据时，Trivium算法的效率大约为4 cycles/byte，而在同样平台上，AES的效率大约为19 cycles/byte，可见Trivium算法的高效性。

\subsection{安全性}

既然期望中的物联网是物物相连，那么必然与我们的日常生活的联系比起现在的互联网会更加紧密，自然对于安全的要求更不可忽略。这里又要提到流密码的特点，在1949年Shannon证明了只有一次一密的密码体制是绝对安全的，而“一次一密”正式流密码的密码方案雏形，如果流密码的密码流是真正随机且和消息流长度相同的话，这时的流密码就是一次一密的密码体制。

当然这并不是说Trivium就绝对安全了，事实上，对于Trivium算法已经有不少的攻击研究了。虽然目前对Trivium算法最有效的攻击仍是暴力破解，但也有不少其他方案很接近了。例如，Michael Vielhaber曾针对将初始化状态更新次数降至576轮的变种Trivium算法用仅仅$2^{12.3}$步攻破\parencite{cryptoeprint:2007:413}。于是，其他一些作者基于此猜测使用这种攻击技术可能可以攻破1100轮初始化状态更新次数的Trivium算法甚至攻破原本的Trivium算法\parencite{cryptoeprint:2008:385}。之后，有人得到了需要$2^{68}$步来攻破的针对一种将初始化状态更新次数降至799轮的变种Trivium算法的立体攻击\parencite{cryptoeprint:2015:312}。另一种攻击使用大约$2^{89.5}$步（每步都约为一个简单的穷举算法的量级）恢复了所有寄存器的内部状态，即也能找到密钥\parencite{cryptoeprint:2007:021}。基于同样的原理，被削弱的变种Trivium算法通过一种被称为equation-solving的技术攻破\parencite{raddum2006cryptanalytic}。Trivium算法共288位内部状态，因此照理应需要$2^{144}$步才能攻破，而这些攻击通过改良在流密码攻击中的时间空间权衡，表明如果仅仅对Trivium算法增加密钥长度，而非做其他改变，那么Trivium算法仍不会安全。

但是，虽然上述这些描述看似Trivium算法被攻破指日可待，但其实并不一定如此。首先，虽然比起原本需要$2^{144}$步而言，这些攻击确实大大降低了时间空间消耗，但他们需要的计算量级仍然不可以说是任何人都能做到的，而且也无法保障在攻击期间不会更换密钥，只要更换密钥的周期小于攻击的时间一样能保障安全。另外值得注意的是，所谓的攻击，并非就直接给一个使用Trivium算法的设备，然后就让研究者攻击，而是都会做很多假定，比如有的假定把Trivium算法初始的内部状态更新轮数减少，有的假定可以操纵明文的输入，有的假定可以随时看到内部状态，有的假定甚至可以更改一两位内部状态，这些假定使这些攻击得以成立，但并不是说实际应用中就能实现。比如Trivium算法初始的内部状态更新轮数，这个肯定不是随便一个厂商能自己决定改的。再比如物联网中实际用的时候很多物品如果要通信，那使用的肯定都是固定的一些消息，而不可能是用户都能自己规定，这样自己操纵明文这块也走不通了。比较可行的是看内部状态或者修改内部状态这种，但实际上Trivium算法是硬件实现，速度非常快，是否能真的导出实时内部状态或修改也是一大问题。

因此，既然至今为止对Trivium算法最有效的攻击手段仍是暴力破解，那么至少在当下Trivium算法的理论安全性是可以有保障的，因此使用Trivium算法时要注意的安全问题应该是密钥和初始向量的选取，上述章节中也提到可以构建出小周期的初始内部状态，那么要保障Trivium算法的安全性就应该避免初始内部状态落在这些可以简单构建出的能产生小周期的初始内部状态中，譬如，Trivium算法要求初始内部状态末尾是3个1，这就很有效地防止了会产生周期为3的初始内部状态的出现。因此，现阶段可以做一个类似黑名单的机制，把那些能产生小周期的初始内部状态放在黑名单中，避免使用他们，又或者如果能反其道而行，找到能构建出产生大周期的内部状态的方法，那也可以有效保障Trivium算法的安全性。

\section{假想应用场景}

\subsection{背景}

\subsection{设计}